# O que √© o pacote core?

O pacote `core` √© o principal componente do StarDust, do qual todos os outros pacotes e aplica√ß√µes dependem.

# Implementa√ß√£o

## üåê Dom√≠nio

No DDD (Domain-Driven Design), o dom√≠nio √© o cora√ß√£o do sistema - √© a √°rea de conhecimento ou atividade que o software visa resolver. O StarDust segue este mesmo princ√≠pio, representando regras de neg√≥cio e comportamentos essenciais no n√∫cleo do sistema.

Assim, o dom√≠nio √© a principal camada do `core` do StarDust. Por esta raz√£o, priorizamos a legibilidade, a padroniza√ß√£o e a alta cobertura de testes nesta camada.

A implementa√ß√£o do dom√≠nio segue os princ√≠pios da modelagem t√°tica do DDD (com algumas adapta√ß√µes), aderindo √†s regras do *[Object Calisthenics](https://developerhandbook.stakater.com/architecture/object-calisthenics.html)* e contendo exclusivamente classes que representam os objetos de dom√≠nio descritos abaixo.

-----

### Entidade

Uma classe que representa algo identific√°vel por um `id`, cujas propriedades podem mudar ao longo do tempo.

> Exemplo: Um Foguete como item de loja pode ter seu pre√ßo alterado.

Uma entidade deve seguir este padr√£o:

  - Ter um construtor privado.
  - Ser criada a partir de um `dto` usando um m√©todo est√°tico chamado `create`. Toda entidade requer um `dto`.
  - Ter um m√©todo que converte a entidade de volta para um `dto`.
  - N√£o deve ser uma classe an√™mica (com apenas getters e setters), mas deve conter m√©todos que executam regras de neg√≥cio ou comportamentos importantes.
  - N√£o pode ser herdada por nenhuma subclasse; para isso, `abstracts` devem ser usados.

-----

### Estrutura

Este √© o objeto de valor descrito no DDD, uma classe que representa algo imut√°vel e identificado pela combina√ß√£o de seus atributos (em vez de um `id`).

> Exemplo: Poderia haver um objeto chamado `Level`, que encapsula o algoritmo de como um usu√°rio sobe de n√≠vel.

Uma estrutura deve seguir este padr√£o:

  - Ter um construtor privado.
  - Ser criada a partir de valores primitivos ou de um `dto` atrav√©s de um m√©todo est√°tico chamado `create`. A maioria dos `objetos` n√£o requer um `dto`, mas pode haver casos raros em que seja necess√°rio.
  - Ter todos os seus atributos p√∫blicos e constantes (readonly).
  - N√£o deve ser uma classe an√™mica, mas deve conter m√©todos com l√≥gica de neg√≥cios relevante.
  - Para alterar uma propriedade de um `objeto`, uma nova inst√¢ncia da classe deve ser criada. Assim, quase todos os m√©todos de um `objeto` retornam uma nova inst√¢ncia de si mesmo.
  - Pode conter outros `objetos` e `entidades` como atributos. Ao se associar a entidades via agrega√ß√£o, `aggregates` devem ser usados.

-----

### Agregado

No DDD, um *Agregado* √© um cluster de objetos de dom√≠nio (entidades e objetos de valor) que formam uma unidade de consist√™ncia e integridade. No StarDust, um `agregado` √© uma classe que encapsula uma entidade que tem uma rela√ß√£o de agrega√ß√£o 1:1 com outra entidade.

> Exemplo: Todo usu√°rio tem um avatar. No entanto, para criar um usu√°rio, n√£o √© necess√°rio fornecer todos os atributos do avatar, apenas seu `id`. Neste caso, a entidade `User` tem um `AvatarAggregate` como atributo, em vez de referenciar diretamente a entidade `Avatar`.

Um `agregado` deve seguir este padr√£o:

  - Ter um atributo `id` (obrigat√≥rio) e um atributo `entity` (que pode ser `undefined`).
  - O atributo `id` deve ser exatamente o mesmo que o `id` da entidade agregada.
  - O atributo `entity` deve ter o tipo da entidade correspondente.

Cada `agregado` deve ter um `dto` correspondente, no qual o atributo `entity` √© representado como um `dto` com o tipo do `dto` da entidade original.

-----

### Evento

Eventos de dom√≠nio s√£o classes que representam mensagens indicando que algo importante aconteceu no dom√≠nio - algo que j√° ocorreu e que o neg√≥cio se importa. Todo evento carrega um `payload`, um conjunto de dados primitivos que descreve o que aconteceu e pode ser relevante para outras partes do sistema.

Os eventos s√£o usados para promover a comunica√ß√£o entre os m√≥dulos do StarDust, mantendo-os independentes uns dos outros.

Um `evento` deve seguir este padr√£o:

  - Ser nomeado no tempo passado e terminar com o sufixo `Event`, como `UserCreatedEvent`, `StarUnlockedEvent`, `LastTierReachedEvent`.
  - Garantir que todos os dados do `payload` sejam p√∫blicos e imut√°veis.
  - Conter uma propriedade est√°tica chamada `key`, do tipo `string`, que indica o nome do evento e o m√≥dulo onde foi despachado.

-----

### Abstrato

Uma classe base destinada a ser estendida por elementos de dom√≠nio para compartilhar comportamentos comuns, deixando a implementa√ß√£o de partes espec√≠ficas para as subclasses.

Um `abstrato` tamb√©m pode ser usado para aplicar o [padr√£o Strategy](https://refactoring.guru/design-patterns/strategy), permitindo a sele√ß√£o din√¢mica de algoritmos ou comportamentos de v√°rias op√ß√µes sem modificar a classe que os utiliza.

-----

### Erro

Uma classe que representa um erro relacionado a uma regra de neg√≥cio espec√≠fica, indicando que a execu√ß√£o n√£o pode continuar.

Uma classe de `erro` pode ser estendida para criar outras classes de erro especializadas.

Deve seguir este padr√£o:

  - Herdar da classe base `Error` da linguagem.
  - Conter apenas atributos com tipos primitivos e imut√°veis.
  - Ter o sufixo `Error`, como `UserNotFoundError`, `StarLockedError`, `ChallengeNotPublicError`.
  - N√£o deve ter m√©todos, apenas atributos.

-----

### F√°brica

Uma f√°brica √© uma classe que encapsula a l√≥gica para criar objetos, especialmente quando essa l√≥gica √© complexa ou depende de outras entidades/servi√ßos. Ela garante que entidades ou agregados sejam criados de forma consistente e v√°lida, sem expor essa complexidade a outras partes do sistema.

Uma `f√°brica` deve seguir este padr√£o:

  - Conter um √∫nico m√©todo p√∫blico chamado `produce`, que cria e retorna o tipo esperado.
  - Ter o sufixo `Factory`, como `UserFactory`, `PlanetFactory`, `ChallengeFactory`.

## üìë Interfaces

S√£o contratos que definem como um manipulador, gateway ou protocolo deve se comportar, exclusivamente atrav√©s de m√©todos. Uma interface pode ser implementada por uma classe ou uma fun√ß√£o. No caso de uma fun√ß√£o, ela deve retornar um objeto que cont√©m os m√©todos estabelecidos pela interface em quest√£o.

As interfaces s√£o usadas para aplicar o princ√≠pio da invers√£o de depend√™ncia para desacoplar aplica√ß√µes, servi√ßos e bibliotecas.

## üì§ Respostas

S√£o classes que estabelecem o formato de retorno de um m√©todo com o objetivo de padronizar as respostas em grande escala. Este tipo de classe √© inspirado no [Padr√£o Result](https://medium.com/@wgyxxbf/result-pattern-a01729f42f8c).

> Por exemplo: `RestResponse` pode encapsular a resposta HTTP, contendo c√≥digo de status, cabe√ßalhos, corpo, etc. `PaginationResponse` encapsula o n√∫mero total de p√°ginas e itens, e assim por diante.

Al√©m disso, uma `resposta` pode conter outra `resposta`. Por exemplo, seguindo o exemplo acima, a propriedade `body` de `ApiResponse` poderia ser do tipo `PaginationResponse`.

## üõçÔ∏è Data Transfer Objects (DTOs)

S√£o objetos simples usados para transportar dados entre camadas de um sistema ou entre sistemas diferentes, sem conter nenhuma l√≥gica de neg√≥cios. Eles s√£o geralmente usados para criar `entidades`, `estruturas` (objetos de valor) e `agregados`.

Um `dto` deve seguir este padr√£o:

  - Conter apenas atributos de tipos primitivos, todos p√∫blicos e mut√°veis.
  - Terminar com o sufixo `Dto`, como `UserDto`, `StarDto`, `PlanetDto`.
  - N√£o ter m√©todos/comportamentos.

## ‚ú® Casos de uso

S√£o classes que representam as a√ß√µes que o sistema executa do ponto de vista do neg√≥cio. Por exemplo, "Criar pedido", "Enviar email de boas-vindas", "Atualizar perfil do usu√°rio", "Exportar relat√≥rio em PDF".

Eles orquestram a l√≥gica de neg√≥cios chamando elementos de dom√≠nio e interfaces.

Um Caso de Uso segue este padr√£o:

  - Um nome claro, como `CreateChallenge`, `SendConfirmationEmail`, `GenerateReport`, `ListRockets`, `GetAvatar`.
  - Um m√©todo principal, geralmente chamado `do()`. Todos os outros m√©todos no `caso de uso` devem ser privados.
  - Um `caso de uso` n√£o deve receber ou retornar nenhum elemento de dom√≠nio diretamente, mas apenas `dtos`.
  - Todas as depend√™ncias de um `caso de uso` devem ser constantes e interfaces.

## ü•∏ Fakers

S√£o classes respons√°veis por gerar objetos de dom√≠nio com dados fict√≠cios. Seu principal objetivo √© agilizar a cria√ß√£o de testes, seja para testes automatizados ou visuais, fornecendo rapidamente dados realistas sem a necessidade de usar informa√ß√µes reais.

Um faker segue este padr√£o:

  - Terminar com o sufixo `Faker`, como `CommentsFaker`, `UsersFaker`, `CategoriesFaker`.
  - Conter apenas m√©todos est√°ticos.
  - Ter alguns ou todos os seguintes m√©todos:
    `fake` -> Retorna o objeto de dom√≠nio. Aceita um DTO como base, se necess√°rio.
    `fakeMany` -> Retorna uma lista de objetos do mesmo tipo do objeto de dom√≠nio.
    `fakeDto` -> Retorna o DTO do objeto de dom√≠nio. Aceita um DTO como base, se necess√°rio.
    `fakeManyDto` -> Retorna uma lista de DTOs do objeto de dom√≠nio. Aceita um DTO base e o n√∫mero de itens a serem falsificados como par√¢metros.

## ü§° Mocks

Um mock √© um objeto simulado que imita o comportamento de componentes reais em sistemas de software, especialmente em testes. √â usado para isolar a parte do sistema que est√° sendo testada, evitando a necessidade de interagir com depend√™ncias externas como bancos de dados, APIs ou outros servi√ßos. No pacote core, os mocks implementam interfaces para substituir implementa√ß√µes reais em casos de uso e objetos de dom√≠nio.

Um mock segue este padr√£o:

  - Terminar com o sufixo `Mock`, como `ProfileServiceMock`, `ShopServiceMock`, `AuthServiceMock`.
  - Se a persist√™ncia for necess√°ria, deve ser apenas em mem√≥ria.

# Desenvolvimento

## Bibliotecas

  - [Faker.js](https://fakerjs.dev) - Uma biblioteca usada para gerar rapidamente dados falsos.
  - [Dayjs](https://day.js.org/) - Uma biblioteca para trabalhar com datas em JavaScript.
  - [UUID](https://www.npmjs.com/package/uuid) - Uma biblioteca para gerar [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).

## Executando os testes

**Clone o reposit√≥rio**

```bash
git clone https://github.com/JohnPetros/stardust.git
```

**Navegue para o diret√≥rio do pacote core**

```bash
cd ./stardust/packages/core
```

**Instale as depend√™ncias**

```bash
npm install
```

**Execute os testes**

```bash
npm run tests
```

## Estrutura de Pastas

```
üì¶ pacote core
‚îî‚îÄ src
   ‚îî‚îÄ <Nome do M√≥dulo>
      ‚îú‚îÄ ‚ú® casos de uso
      ‚îú‚îÄ üìë interfaces
      ‚îú‚îÄ üì§ respostas
      ‚îú‚îÄ ü™® constantes
      ‚îú‚îÄ üìñ libs
      ‚îî‚îÄ üåê dom√≠nio
         ‚îú‚îÄ abstracts
         ‚îú‚îÄ entities
         ‚îú‚îÄ structures
         ‚îú‚îÄ events
         ‚îú‚îÄ errors
         ‚îî‚îÄ factories
```

Note que a estrutura de pastas mostrada acima √© um superconjunto de todas as pastas poss√≠veis dentro de um m√≥dulo. Cada m√≥dulo ter√° um subconjunto dessas pastas, dependendo de suas necessidades espec√≠ficas. Por exemplo, alguns m√≥dulos podem n√£o ter uma pasta `use-cases` se definirem apenas objetos de dom√≠nio.

Os arquivos de teste para `entities`, `structures` e `use-cases` s√£o colocados dentro de uma pasta chamada `tests` dentro de suas respectivas pastas onde o c√≥digo original a ser testado est√° localizado. Da mesma forma, os arquivos de implementa√ß√£o de `faker` para `entities` e `structures` s√£o colocados dentro de uma pasta chamada `fakers` dentro das pastas `entities` e `structures`.

```
üì¶
‚îú‚îÄ use-cases
‚îÇ  ‚îú‚îÄ üß™ tests
‚îÇ  ‚îî‚îÄ ...
‚îî‚îÄ domain
   ‚îú‚îÄ entities
   ‚îÇ  ‚îú‚îÄ üõçÔ∏è dtos
   ‚îÇ  ‚îú‚îÄ üß™ tests
   ‚îÇ  ‚îú‚îÄ ü•∏ fakers
   ‚îÇ  ‚îî‚îÄ ...
   ‚îî‚îÄ structures
      ‚îú‚îÄ üß™ tests
      ‚îú‚îÄ ü•∏ fakers
      ‚îî‚îÄ ...
```